To Do:
- Add maken
- Day veranderen:
	- Loop klasse maken in Schedule
		- Bevat een linkedlist van nodes:
			- Bevat order
			- Bevat lijst van (next, prev) <- voor elke keer dat de node is ingepland
				-> length(lijst(next,prev)) == freq(order) 
					(ervanuitgaande dat we een order altijd geheel inplannen, which we do)
		- Tijd Over
		- Ruimte Over in vuilniswagen.
	- Tijd over
	- AddNodeToLoop(Node n, Loop lp, Location la) Methode maken

Add(Node a)
	Node closest = null;
	loop_of_closest = null
	double closestdistance = double.MaxValue

	foreach(mogelijke_dag in mogelijke_dagen)
		if (mogelijke_dag.Time_Left < a.Time) continue;
		else
			foreach (loop in day)
				if (loop.Time_Left < a.Time || loop.Space_Left < a.Space) continue
				else 
					foreach (Node in Loop)
						if (GetDistance(Node, a) < closestdistance)
							closestdistance = GetDistance(Node, a)
							closest = Node
							loop_of_closest = loop

	return (GetDelta(loop, a, closest), current_state))

if (Zoekalgoritme.Approves(Add(Node a))) => AddNodeToLoop(loop, a, closest)



Format Inlevermodel

Iedere regel bevat vier entries gescheiden door een punt-komma
1.	Vrachtautonummer (1 of 2)
2.	Dagnummer (maandag =1, dinsdag =2, …, vrijdag =5)
3.	Hoeveelste adres dat het voertuig op die dag aandoet (begin met 1, 2, …)
4.	Id. van het adres (uit orderbestand.txt); de stort heeft nummer 0. (OrderId)
Voorbeeld: Op maandag begint voertuig 1 met adres 10, daarna 20, dan afstorten, en vervolgens door naar 30. 
Op het eind van de dag gaat de auto weer naar de stort; dit moet je ook aangeven.
1; 1; 1; 10
1; 1; 2; 20
1; 1; 3; 0
1; 1; 4; 30

SWEETSPOT PARAMETERS:
	BESTE MET CLUSTER:
	clusterCount = 4, 5, 6 <- verschilt wann welke beter.
	nonPlannedOrders = orders.OrderBy(o => o.Cluster).ThenBy(o => o.Frequency).ThenBy(o => o.Score).ToList();
	opCount = 20
	Hillclimb
	int index = rnd.Next(0, s.nonPlannedOrders.Count / 5);
	AddByCluster BEST

	TOT NU TOE BESTE (DUS BETER DAN MET CLUSTER):
	nonPlannedOrders = orders.OrderBy(o => o.Score).ThenByDescending(o => o.Frequency).ToList();
	opCount = 20
	Hillclimb
	int index = rnd.Next(0, s.nonPlannedOrders.Count / 5);
	Add BEST



http://178.85.229.78:8067/team/157557372232042770


#region Transfer
class Schedule
	TransferResult Transfer()
		foreach (Day d in Days)
			Node n = EvaluateDeletion(d) // Krijg de node die het beste is om te verwijderen
		foreach (Possible_Day in n.PossibleDays) // 1 iff n.Freq > 1, else 5
			Day wheretoAdd = EvaluateAddition(Possible_Day, n)
		return new TransferResult(n, wheretoAdd, delta)
	class Day
		bool EvaluateDeletion(out Node n)
			foreach (Loop l in Loops)
				l.EvaluateDeletion()
		class Loop
			bool EvaluateDeletion(out Node n)
				foreach (Node o in Nodes)
					if (TimefromPrevToO + TimeFromOToNext - TimeFromPrevToNext + (o.TimeToEmpty * 2) > worstTime)
						Node worst = o
				return worst
			class Node
#endregion

#region Swap
class Schedule
	class Day
		class Loop
			class Node
#endregion

#region Iets_Met_Cluster
class Schedule
	class Day
		class Loop
			class Node
#endregion



Evolutionairy Programming Approach:
Iterate till convergence || maxiterations || user interupt:
	Schedule[parentCount] Parents;
	List<Schedule> Children = new List<Schedule>(to_be_determined);
	int childrenPerParents = zeg_t_maar;
	for (int p = 1; p < Parents.Count; p-=-1)
		List<Schedule> offSpring = GenerateChildren(Parents[p-1], Parents[p], childrenPerParents);
		Children.Concat(offSpring);
	Random rnd = new Random()
	for (int m = 0; m < mutation_count; m-=-1)
		ApplyMutation(Children[rnd.Next(0, Children.Count)]);
	Parents = GetBestOffSpring(Children, parentCount);


Algemene Thoughts:
	Mutatie moet te doen zijn, want gwn een random operator toepassen (en die operator een random TOEGESTANE plek laten pakken
		want fuck heuristiek, tis per slot mutatie).

Moeilijkheden / dingen te bedenken:
	GenerateChildren gaat lastig worden.
	Hoe ga je van 2 parents x aantal kinderen maken op basis van de eigenschappen van een parent...
		2 Schedules...
		Je wilt het lieftst 'de beste eigenschappen' van die 2 en dat op x aantal mogelijkheden combineren.
		- Je kan alles dat overeenkomt gebruiken als base_child
			- dan voor elke extra order die is ingepland per parent deze toevoegen aan base_child als nieuw kind.
				-> voor zover dat toegestaan is
		- Je kan alles wat ze van elkaar verschillen nemen als child
		- foreach day, foreach truck pak de loop van de parent met de kleinste time.

---
Fleshed out werkwijze:
- Variabelen:
	population_size = ....
	parent_amount = ....

- Initialisatie:
	-> Volledige random add van zoveel mogelijk orders voor population_size aantal schedules.
		-> als een orders geadd wordt, dan moet de volledige order geadd worden.
- Iteratie:
	-> Sorteer populatie op basis van Score.
	-> Bepaal parent_amount parents uit de populatie.
		-> 



		