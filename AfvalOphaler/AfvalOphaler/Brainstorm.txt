===================
= SUBMISSION INFO =
===================

Format Inlevermodel

Iedere regel bevat vier entries gescheiden door een punt-komma
1.	Vrachtautonummer (1 of 2)
2.	Dagnummer (maandag =1, dinsdag =2, …, vrijdag =5)
3.	Hoeveelste adres dat het voertuig op die dag aandoet (begin met 1, 2, …)
4.	Id. van het adres (uit orderbestand.txt); de stort heeft nummer 0. (OrderId)
Voorbeeld: Op maandag begint voertuig 1 met adres 10, daarna 20, dan afstorten, en vervolgens door naar 30. 
Op het eind van de dag gaat de auto weer naar de stort; dit moet je ook aangeven.
1; 1; 1; 10
1; 1; 2; 20
1; 1; 3; 0
1; 1; 4; 30

http://178.85.229.78:8067/team/157557372232042770

=============
=== TO DO ===
=============

- SWAP FIXEN
- operators kunnen laten werken met hogere freq orders
- dumps verwijderen / toevoegen
- probability of operators dynamisch maken
- andere zoekalgs implementeren

===========================
= AANPAK MOEILIJKE DINGEN =
===========================

adden en verwijderen van dumps tijdens het zoeken:
- Toestaan dat dit gebeurd in AddOperator/DeleteOperator

- In de optimizer doen
	De optimizer kijkt voor elke dayroute of een dump verwijderd kan worden of dat er één toegevoegd moet worden
	Verwijderen kan altijd zolang de constraints niet geschonden worden.
	Adden zou in theorie ook altijd mogen 
	- Voor:
		- Je weet zeker dat de dumps daadwerkelijk verwijderd/toegevoegd worden
	- Tegen:

===========================================
=== Evolutionairy Programming Approach: ===
===========================================

Iterate till convergence || maxiterations || user interupt:
	Schedule[parentCount] Parents;
	List<Schedule> Children = new List<Schedule>(to_be_determined);
	int childrenPerParents = zeg_t_maar;
	for (int p = 1; p < Parents.Count; p-=-1)
		List<Schedule> offSpring = GenerateChildren(Parents[p-1], Parents[p], childrenPerParents);
		Children.Concat(offSpring);
	Random rnd = new Random()
	for (int m = 0; m < mutation_count; m-=-1)
		ApplyMutation(Children[rnd.Next(0, Children.Count)]);
	Parents = GetBestOffSpring(Children, parentCount);


Algemene Thoughts:
	Mutatie moet te doen zijn, want gwn een random operator toepassen (en die operator een random TOEGESTANE plek laten pakken
		want fuck heuristiek, tis per slot mutatie).

Moeilijkheden / dingen te bedenken:
	GenerateChildren gaat lastig worden.
	Hoe ga je van 2 parents x aantal kinderen maken op basis van de eigenschappen van een parent...
		2 Schedules...
		Je wilt het lieftst 'de beste eigenschappen' van die 2 en dat op x aantal mogelijkheden combineren.
		- Je kan alles dat overeenkomt gebruiken als base_child
			- dan voor elke extra order die is ingepland per parent deze toevoegen aan base_child als nieuw kind.
				-> voor zover dat toegestaan is
		- Je kan alles wat ze van elkaar verschillen nemen als child
		- foreach day, foreach truck pak de loop van de parent met de kleinste time.

=== Genetic representation: === //Een andere manier van searchspace representatie voor Evo-Alg.
	moet een reeks van cijfers zijn, het liefst bits...
	Optie 1:
		de lijst van orders altijd dezelfde volgorde houden
		een order moet altijd of niet, of volledig ingepland zijn.
		de reeks cijfers:
		voor elke order, 
			voor elke keer dat die ingepland moet worden (dus lenght(freq))
				0,0 -> niet ingepland
				d,t,l -> ingepland op dag d, in truck t, in loop l.
		
		Offspring genereren:
			population.OrderBy(p => p.Score)
			pak de n best en m random schedules uit de population.
			Pak telkens 2 parents:
				- basiskind is p1 XOR p2
				- for elke order (p2 - (p1 XOR p2))
					nieuwkind = basiskind + order
				- for elke order (p1 - (p1 XOR p2))
					nieuwkind = basiskind + order
		mutation:
			pak een random kind, maak een kopie waarbij:
				een order die ingepland is verwijderen
				een order die ingepland is op een andere plek zetten, met al zn freq of maar 1 inplan.
				een order die NIET ingepland is inplannen op:
					NOG BESLISSEN WAT:
					- random toegestaan moment
					- beste toegestane moment
					- eerste/laatste toegestane moment
			doe dit net zo vaak totdat populationSize == desiredPopSize


		Aangezien kinderen sws de orders bevatten die beide ouders gemeen hebben is dit aardig
			adding biased, drm moet mutation miss wat meer deletion biased worden.


---
Fleshed out werkwijze:
- Variabelen:
	population_size = ....
	parent_amount = ....

- Initialisatie:
	-> Volledige random add van zoveel mogelijk orders voor population_size aantal schedules.
		-> als een orders geadd wordt, dan moet de volledige order geadd worden.
- Iteratie:
	-> Sorteer populatie op basis van Score.
	-> Bepaal parent_amount parents uit de populatie.
		-> 




		